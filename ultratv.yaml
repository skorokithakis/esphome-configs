esphome:
  name: bedroom-bedtime
  friendly_name: Bedtime

esp8266:
  board: d1_mini

# Enable logging
logger:

web_server:
  port: 80

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  min_auth_mode: WPA2

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Bedtime"
    password: "12345678"

mqtt:
  broker: !secret mqtt_hostname
  on_json_message:
    - topic: zigbee2mqtt/sensors/office/outdoors_temperature
      then:
        - lambda: |-
            id(outdoor_temp).publish_state(x["temperature"]);
    - topic: zigbee2mqtt/sensors/office/closet_temperature
      then:
        - lambda: |-
            id(indoor_humidity).publish_state(x["humidity"]);

captive_portal:

globals:
  - id: last_brightness_pct
    type: int
    initial_value: "-1"

spi:
  clk_pin: GPIO14
  mosi_pin: GPIO13
  interface: hardware
  id: spihwd

# status_led:
#   pin: GPIO2

output:
  - platform: esp8266_pwm
    pin: GPIO05
    frequency: 200 Hz
    inverted: true
    id: backlight_pwm

light:
  - platform: monochromatic
    output: backlight_pwm
    name: "Backlight"
    id: backlight
    restore_mode: RESTORE_AND_ON

image:
  - file: "synthwave_bg.png"
    id: background
    type: RGB

font:
  - file: "gfonts://Bebas+Neue"
    id: font_time
    size: 126

  - file: "gfonts://Exo+2"
    id: font_info
    size: 22

display:
  - platform: mipi_spi
    model: st7789v
    spi_id: spihwd
    dimensions:
      height: 240
      width: 240
      offset_height: 0
      offset_width: 0
    invert_colors: true
    dc_pin: GPIO00
    reset_pin: GPIO02
    #backlight_pin: GPIO25
    color_depth: 8
    update_interval: 1s
    id: disp
    spi_mode: mode3
    lambda: |-
      it.image(0, 0, id(background));

      Color red = Color(255, 80, 80);
      Color white = Color(255, 255, 255);
      const int left_x = 10;
      const int date_day_y = 10;
      const int date_date_y = 40;
      const int temp_y = 105;
      const int humidity_y = 170;
      const int co2_y = 200;
      int bx, by, bw, bh;

      // Time on the right, hardcoded positions.
      auto time = id(current_time).now();
      const int time_x = 230;
      const int hour_y = 150;
      const int minute_y = 100;
      it.strftime(time_x, hour_y, id(font_time), white, TextAlign::BOTTOM_RIGHT, "%H", time);
      it.strftime(time_x, minute_y, id(font_time), red, TextAlign::TOP_RIGHT, "%M", time);

      // Left side: date, temp, humidity/co2 stacked vertically.
      // Date at top.
      if (time.is_valid()) {
        const char* daynames[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
        const char* dayname = daynames[time.day_of_week - 1];
        it.print(left_x, date_day_y, id(font_info), red, dayname);
        char date_str[8];
        sprintf(date_str, "%02d/%02d", time.day_of_month, time.month);
        it.print(left_x, date_date_y, id(font_info), white, date_str);
      }

      float temp = isnan(id(outdoor_temp).state) ? 0 : id(outdoor_temp).state;
      float humidity = isnan(id(indoor_humidity).state) ? 0 : id(indoor_humidity).state;
      float co2 = isnan(id(bedroom_co2).state) ? 0 : id(bedroom_co2).state;

      // Temperature in the middle.
      char temp_num[8];
      sprintf(temp_num, "%.1f", temp);
      int pos = left_x;
      it.print(pos, temp_y, id(font_info), white, temp_num);
      it.get_text_bounds(0, 0, temp_num, id(font_info), TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);
      pos += bw;
      it.print(pos, temp_y, id(font_info), red, " °C");

      // Humidity and CO2 at bottom.
      pos = left_x;
      char hum_str[8];
      sprintf(hum_str, "%.0f", humidity);
      it.print(pos, humidity_y, id(font_info), white, hum_str);
      it.get_text_bounds(0, 0, hum_str, id(font_info), TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);
      pos += bw;
      it.print(pos, humidity_y, id(font_info), red, "%");

      char co2_str[8];
      sprintf(co2_str, "%.1f", co2 / 1000);
      pos = left_x;
      it.print(pos, co2_y, id(font_info), white, co2_str);
      it.get_text_bounds(0, 0, co2_str, id(font_info), TextAlign::TOP_LEFT, &bx, &by, &bw, &bh);
      pos += bw;
      it.print(pos, co2_y, id(font_info), red, "ppt");

sensor:
  - platform: adc
    pin: A0
    name: "Ambient Light"
    id: ambient_light
    update_interval: 1s
    unit_of_measurement: "mV"
    accuracy_decimals: 0
    filters:
      - multiply: 1000
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1

  - platform: mqtt_subscribe
    name: "Bedroom CO2"
    id: bedroom_co2
    topic: zigbee2mqtt/sensors/bedroom/co2

  - platform: template
    name: "Outdoor Temperature"
    id: outdoor_temp
    unit_of_measurement: "°C"

  - platform: template
    name: "Indoor Humidity"
    id: indoor_humidity
    unit_of_measurement: "%"

time:
  - platform: sntp
    id: current_time
    timezone: Europe/Athens
    servers:
      - 0.gr.pool.ntp.org
      - 1.gr.pool.ntp.org
      - 2.gr.pool.ntp.org

interval:
  - interval: 1s
    then:
      - lambda: |-
          float light = id(ambient_light).state;
          if (isnan(light)) return;

          const int kMinBrightnessPct = 9;
          const int kMaxBrightnessPct = 60;
          const float kLightMinMv = 50;
          const float kLightMaxMv = 250;

          float normalized = (light - kLightMinMv) / (kLightMaxMv - kLightMinMv);
          if (normalized < 0) normalized = 0;
          if (normalized > 1) normalized = 1;
          int brightness_pct = kMinBrightnessPct + normalized * (kMaxBrightnessPct - kMinBrightnessPct);

          ESP_LOGI("backlight", "Light: %.0f mV, Brightness: %d%%", light, brightness_pct);

          if (brightness_pct == id(last_brightness_pct)) return;
          id(last_brightness_pct) = brightness_pct;

          auto call = id(backlight).turn_on();
          call.set_brightness(brightness_pct / 100.0f);
          call.perform();
